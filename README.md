# Nanomites
Nanomites technique from Nanomites.w32 virus

Określenie nanomit kojarzy się z mikroskopijnym robotem wielkości rzędu nanometrów. Taką też nazwę nadano znanej od długiego czasu, ale wciąż używanej metodzie przeciwko inżynierii odwrotnej kodu (ang. RCE). A dokładnie przeciwko odbudowie kodu analizowanej aplikacji ze zrzutu pamięci procesu. W prostych słowach technika ta polega na wstrzykiwaniu (zamianie) określonych instrukcji (przeważnie skoków — JZ, JNZ, JC etc.) w języku Asembler na rozkazy przerwania INT 3h określane nanomitami. Podczas wykonania programu przy trafieniu na nanomit, sterowanie zostaje przekazywane do specjalnej procedury, która decyduje o dalszej ścieżce wykonywania kodu.

Rozkazy INT 3h są umieszczane na poziomie kodu maszynowego. Przy kompilacji programu np. w C++ poszczególne formy kodu to C++, język Asembler, a na końcu kod maszynowy. Rozkaz w języku Asembler w formie tekstowej (np. INT, MOV, JNE etc.) nazywany jest mnemonikiem. Natomiast wartość liczbowa rozkazu w kodzie maszynowym nazywana jest kodem operacyjnym — w skrócie opkodem.
Załóżmy, że dla przykładu chcemy zmienić w programie (pliku .exe) instrukcję skoku JNE (ang. Jump If Not Equal — skocz jeśli nierówne) na instrukcję JE (ang. Jump If Equal — skocz jeśli równe). Rozkaz JNE w architekturze x64 posiada opkod 75h, a rozkaz JE to wartość 74h. Wartości te można znaleźć w dokumentacji procesorów lub na różnych listach opkodów dostępnych w sieci. Zatem zmiana instrukcji Asemblera w programie typu .exe polega na podmianie wartości opkodu. Dla tego przykładu jest to zmiana 75h na 74h. Podobnie jest z wprowadzaniem nanomitów do kodu. Zamienia się opkod określonej instrukcji na nanomit INT 3h, którego kod operacyjny wynosi 0CCh.

Implementacje tej techniki mogą być różne. Standardowy schemat działania polega na zamianie instrukcji skoków warunkowych na rozkaz INT 3h (nazywany nanomitem). Program zabezpieczający przy zamianie opkodów zapisuje rodzaj skoku (JE, JNE, JAE etc.), miejsce gdzie była instrukcja skoku (przesunięcie) oraz miejsce do którego prowadzi instrukcja skoku (przesunięcie). Tutaj możliwe jest podzielenie programu na dwa procesy: sterujący oraz proces zabezpieczanej aplikacji. Proces sterujący posiadałby wtedy procedurę obsługującą wykonanie nanomitu. Dla uproszczenia procedura ta może znajdować się w jednym procesie. Jej zadaniem jest rozpoznanie czy przerwanie INT 3h to nanomit czy nie. A następnie odpowiednia obsługa przerwania czyli odczytanie zapisanego wcześniej rodzaju skoku, sprawdzenie stanu rejestru flag i wykonanie skoku, jeśli warunek jest spełniony.

Przechwytywanie obsługi przerwania INT 3h może być wykonane na kilka sposobów. Jako pierwszy, który przychodzi mi na myśl to strukturalna obsługa wyjątków (ang. SEH). Można też wykonywać debugowanie utworzonego procesu (WaitForDebugEvent(...)).

Program w funkcji głównej (Main) ustawia procedurę obsługi wyjątków funkcją SetUnhandledExceptionFilter(...). Następnie wykonywane jest proste porównanie rejestru RAX z jakąś wartością (cmp rax, 02h). Standardowo po takim porównaniu powinien być skok warunkowy (np. JE, JNE itp.), ale tutaj wstawiony został nanomit. Wykonane jest to za pomocą makra nanomite_here, które przyjmuje dwa parametry: rodzaj skoku i adres do etykiety docelowej. Makro zapisuje potrzebne informacje do struktury, a następnie wywołuje wyjątek int 3h.
Wywołanie wyjątku przekazuje sterowanie do procedury myExceptionHandler. Sprawdza ona rodzaj skoku, warunek na podstawie zachowanego bajtu z rejestru flag i decyduje czy wykonać skok, czy też może przekazać sterowanie do kolejnej instrukcji po int 3h.
Jak już wspomniałem jest to prosty przykład edukacyjny. W przypadku prawdziwej implementacji tej techniki na pewno należałoby dodać szyfrowanie struktury z informacjami o nanomitach, wydzielić procedurę obsługi do osobnego procesu i połączyć to wszystko z innymi technikami. Należałoby też wybrać jakiś język wyższego poziomu np. Visual C++ i używać tylko elementów w języku Asembler, a nie pisać w nim całą aplikację.